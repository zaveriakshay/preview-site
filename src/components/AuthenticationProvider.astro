---
import { authConfigManager } from '../utils/auth-config.ts';

const authConfig = await authConfigManager.loadConfig();
const currentPath = Astro.url.pathname;
const searchParams = Astro.url.searchParams;
const language = searchParams.get('lang') || 'en';

interface AuthUser {
    id: string;
    username: string;
    email: string;
    roles: string[];
    accessToken: string;
    refreshToken: string;
    expiresAt: number;
}
---

<script define:vars={{ authConfig, currentPath, language }}>
class NoqodiAuth {
    constructor(config) {
        this.config = config;
        this.storageKey = 'noqodi_auth_user';
        this.user = null;
        this.initialized = false;
        
        if (typeof window !== 'undefined') {
            this.init();
        }
    }

    async init() {
        if (this.initialized) return;
        
        try {
            this.user = this.loadUserFromStorage();
            
            if (this.user && this.isTokenExpired()) {
                if (this.config.debug.enabled) {
                    console.log('Token expired, attempting refresh...');
                }
                await this.refreshToken();
            }
            
            const urlParams = new URLSearchParams(window.location.search);
            const authCode = urlParams.get('code');
            const state = urlParams.get('state');
            
            if (authCode && state) {
                if (this.config.debug.enabled) {
                    console.log('Processing OAuth callback...');
                }
                await this.handleOAuthCallback(authCode, state);
            }
            
            this.initialized = true;
            this.dispatchAuthEvent('auth:initialized', { user: this.user });
            
        } catch (error) {
            console.error('Auth initialization failed:', error);
            this.clearUserFromStorage();
        }
    }

    isAuthenticated() {
        return this.user && !this.isTokenExpired();
    }

    getUser() {
        return this.user;
    }

    getUserRoles() {
        return this.user?.roles || [];
    }

    isTokenExpired() {
        if (!this.user?.expiresAt) return true;
        const now = Math.floor(Date.now() / 1000);
        const threshold = this.config.session.refreshThreshold;
        return (this.user.expiresAt - now) <= threshold;
    }

    async login(options = {}) {
        try {
            const state = options.state || 'welcome';
            const nonce = options.nonce || this.generateNonce();
            const uiLocale = options.language || language || 'en';
            
            sessionStorage.setItem('auth_state', state);
            sessionStorage.setItem('auth_nonce', nonce);
            sessionStorage.setItem('auth_return_url', window.location.href);
            
            const authUrl = this.generateAuthUrl(state, nonce, uiLocale);
            
            if (this.config.debug.logRedirects) {
                console.log('Redirecting to auth URL:', authUrl);
            }
            
            window.location.href = authUrl;
            
        } catch (error) {
            console.error('Login failed:', error);
            throw error;
        }
    }

    async logout() {
        try {
            const logoutUrl = this.generateLogoutUrl();
            
            this.clearUserFromStorage();
            this.user = null;
            
            this.dispatchAuthEvent('auth:logout');
            
            if (this.config.debug.logRedirects) {
                console.log('Redirecting to logout URL:', logoutUrl);
            }
            
            window.location.href = logoutUrl;
            
        } catch (error) {
            console.error('Logout failed:', error);
            this.clearUserFromStorage();
            this.user = null;
        }
    }

    async handleOAuthCallback(code, state) {
        try {
            const storedState = sessionStorage.getItem('auth_state');
            const storedNonce = sessionStorage.getItem('auth_nonce');
            const returnUrl = sessionStorage.getItem('auth_return_url');
            
            if (state !== storedState) {
                throw new Error('Invalid state parameter');
            }
            
            sessionStorage.removeItem('auth_state');
            sessionStorage.removeItem('auth_nonce');
            sessionStorage.removeItem('auth_return_url');
            
            const tokenData = await this.exchangeCodeForTokens(code);
            const userInfo = await this.fetchUserInfo(tokenData.access_token);
            
            this.user = {
                id: userInfo.sub,
                username: userInfo.preferred_username || userInfo.email,
                email: userInfo.email,
                roles: userInfo.realm_access?.roles || [],
                accessToken: tokenData.access_token,
                refreshToken: tokenData.refresh_token,
                expiresAt: Math.floor(Date.now() / 1000) + tokenData.expires_in
            };
            
            this.saveUserToStorage();
            this.dispatchAuthEvent('auth:login', { user: this.user });
            
            const finalUrl = returnUrl || `${this.config.redirect.baseUrl}${this.config.redirect.welcomePath}`;
            
            if (this.config.debug.logRedirects) {
                console.log('Auth successful, redirecting to:', finalUrl);
            }
            
            window.location.href = finalUrl;
            
        } catch (error) {
            console.error('OAuth callback handling failed:', error);
            throw error;
        }
    }

    async exchangeCodeForTokens(code) {
        const tokenEndpoint = this.config.environment === 'local' 
            ? `${this.config.keycloak.baseUrl}/api/mock-auth/token`
            : `${this.config.keycloak.baseUrl}/realms/${this.config.keycloak.realm}/protocol/openid-connect/token`;
        
        const body = new URLSearchParams({
            grant_type: 'authorization_code',
            client_id: this.config.keycloak.clientId,
            code: code,
            redirect_uri: `${this.config.redirect.baseUrl}${this.config.redirect.returnPath}`
        });

        const response = await fetch(tokenEndpoint, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded',
            },
            body: body.toString()
        });

        if (!response.ok) {
            throw new Error(`Token exchange failed: ${response.statusText}`);
        }

        return await response.json();
    }

    async fetchUserInfo(accessToken) {
        const userInfoEndpoint = this.config.environment === 'local'
            ? `${this.config.keycloak.baseUrl}/api/mock-auth/userinfo`
            : `${this.config.keycloak.baseUrl}/realms/${this.config.keycloak.realm}/protocol/openid-connect/userinfo`;
        
        const response = await fetch(userInfoEndpoint, {
            headers: {
                'Authorization': `Bearer ${accessToken}`,
                'Accept': 'application/json'
            }
        });

        if (!response.ok) {
            throw new Error(`User info fetch failed: ${response.statusText}`);
        }

        return await response.json();
    }

    async refreshToken() {
        if (!this.user?.refreshToken) {
            throw new Error('No refresh token available');
        }

        try {
            const tokenEndpoint = this.config.environment === 'local'
                ? `${this.config.keycloak.baseUrl}/api/mock-auth/token`
                : `${this.config.keycloak.baseUrl}/realms/${this.config.keycloak.realm}/protocol/openid-connect/token`;
            
            const body = new URLSearchParams({
                grant_type: 'refresh_token',
                client_id: this.config.keycloak.clientId,
                refresh_token: this.user.refreshToken
            });

            const response = await fetch(tokenEndpoint, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/x-www-form-urlencoded',
                },
                body: body.toString()
            });

            if (!response.ok) {
                throw new Error(`Token refresh failed: ${response.statusText}`);
            }

            const tokenData = await response.json();
            
            this.user.accessToken = tokenData.access_token;
            this.user.refreshToken = tokenData.refresh_token || this.user.refreshToken;
            this.user.expiresAt = Math.floor(Date.now() / 1000) + tokenData.expires_in;
            
            this.saveUserToStorage();
            this.dispatchAuthEvent('auth:token_refreshed', { user: this.user });
            
        } catch (error) {
            console.error('Token refresh failed:', error);
            this.clearUserFromStorage();
            this.user = null;
            throw error;
        }
    }

    generateAuthUrl(state, nonce, uiLocale) {
        const redirectUri = encodeURIComponent(`${this.config.redirect.baseUrl}${this.config.redirect.returnPath}`);
        
        const params = new URLSearchParams({
            response_type: this.config.keycloak.responseType,
            scope: this.config.keycloak.scope,
            client_id: this.config.keycloak.clientId,
            redirect_uri: redirectUri,
            state: state,
            nonce: nonce
        });

        if (uiLocale) {
            params.set('ui_locales', uiLocale);
        }

        return `${this.config.keycloak.baseUrl}${this.config.keycloak.authEndpoint}?${params.toString()}`;
    }

    generateLogoutUrl() {
        const redirectUri = encodeURIComponent(`${this.config.redirect.baseUrl}/`);
        
        const params = new URLSearchParams({
            redirect_uri: redirectUri
        });

        return `${this.config.keycloak.baseUrl}/realms/${this.config.keycloak.realm}/protocol/openid-connect/logout?${params.toString()}`;
    }

    generateNonce() {
        return Math.random().toString(36).substring(2) + Date.now().toString(36);
    }

    loadUserFromStorage() {
        try {
            const storage = this.config.session.storage === 'sessionStorage' ? sessionStorage : localStorage;
            const userData = storage.getItem(this.storageKey);
            return userData ? JSON.parse(userData) : null;
        } catch (error) {
            console.error('Failed to load user from storage:', error);
            return null;
        }
    }

    saveUserToStorage() {
        try {
            const storage = this.config.session.storage === 'sessionStorage' ? sessionStorage : localStorage;
            storage.setItem(this.storageKey, JSON.stringify(this.user));
        } catch (error) {
            console.error('Failed to save user to storage:', error);
        }
    }

    clearUserFromStorage() {
        try {
            const storage = this.config.session.storage === 'sessionStorage' ? sessionStorage : localStorage;
            storage.removeItem(this.storageKey);
        } catch (error) {
            console.error('Failed to clear user from storage:', error);
        }
    }

    dispatchAuthEvent(eventName, detail = {}) {
        if (typeof window !== 'undefined') {
            window.dispatchEvent(new CustomEvent(eventName, { detail }));
        }
    }

    async checkPageAccess(pagePath, userRoles = null) {
        const roles = userRoles || this.getUserRoles();
        
        try {
            const response = await fetch(`/api/auth/check-access`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': this.user?.accessToken ? `Bearer ${this.user.accessToken}` : ''
                },
                body: JSON.stringify({
                    path: pagePath,
                    roles: roles
                })
            });
            
            if (!response.ok) {
                throw new Error(`Access check failed: ${response.statusText}`);
            }
            
            return await response.json();
        } catch (error) {
            console.error('Page access check failed:', error);
            return {
                visible: false,
                requiresAuth: true,
                error: error.message
            };
        }
    }
}

if (typeof window !== 'undefined') {
    window.noqodiAuth = new NoqodiAuth(authConfig);
}
</script>

<style>
    .auth-loading {
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 2rem;
        color: #68768a;
        font-style: italic;
    }

    .auth-error {
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 2rem;
        color: #dc2626;
        background: #fef2f2;
        border: 1px solid #fecaca;
        border-radius: 8px;
        margin: 1rem 0;
    }

    .auth-login-required {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding: 3rem 2rem;
        text-align: center;
        background: #f8fafc;
        border: 1px solid #e2e8f0;
        border-radius: 12px;
        margin: 2rem 0;
    }

    .auth-login-required h2 {
        color: #1e293b;
        font-size: 1.5rem;
        font-weight: 600;
        margin-bottom: 1rem;
    }

    .auth-login-required p {
        color: #64748b;
        font-size: 1rem;
        margin-bottom: 2rem;
        max-width: 400px;
    }

    .auth-login-button {
        background: #635bff;
        color: white;
        border: none;
        padding: 12px 24px;
        border-radius: 8px;
        font-size: 1rem;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.15s ease;
        text-decoration: none;
        display: inline-flex;
        align-items: center;
        gap: 8px;
    }

    .auth-login-button:hover {
        background: #5a52ff;
        transform: translateY(-2px);
        box-shadow: 0 8px 16px rgba(99, 91, 255, 0.25);
    }

    .auth-user-info {
        display: flex;
        align-items: center;
        gap: 12px;
        padding: 8px 16px;
        background: #f8fafc;
        border: 1px solid #e2e8f0;
        border-radius: 8px;
        font-size: 0.875rem;
    }

    .auth-user-avatar {
        width: 32px;
        height: 32px;
        border-radius: 50%;
        background: #635bff;
        color: white;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: 600;
        font-size: 0.75rem;
    }

    .auth-user-details {
        flex: 1;
    }

    .auth-user-name {
        font-weight: 500;
        color: #1e293b;
    }

    .auth-user-roles {
        color: #64748b;
        font-size: 0.75rem;
    }

    .auth-logout-button {
        background: none;
        border: 1px solid #e2e8f0;
        color: #64748b;
        padding: 4px 8px;
        border-radius: 4px;
        font-size: 0.75rem;
        cursor: pointer;
        transition: all 0.15s ease;
    }

    .auth-logout-button:hover {
        background: #f1f5f9;
        color: #334155;
    }
</style>